# GridLAB-D Modules


## Globals

GridLAB-D supports dynamic definition of global variables. All of these are accessible through the core by any module at any time, and are exported to the output file as a group. These variables control output verbosity and output files, how many threads to use, how to output the results, the strictness of the global variable creation, various module states, etc. 


Using Global Variables

Global variables are created and accessed through GL_* functions. There is no particular constraint on what can be done with the global variables, but it is recommended to declare them in the module init functions, and explicitly link them to a static variable. 

The **GLOBALVAR** struct should be considered opaque. It is much simpler and much more reliable to only use the struct as a handle for getting and setting the value within the variable. 

### GLOBALVAR *gl_global_create(char *name, …)

Explicitly creates and defines a global variable. The first argument is the name of the variable, which must be unique. The subsequent arguments must specify a PT_type as a second argument, then any arguments for that type, such as keywords, key values, and access types. 

Example: 


`   gl_global_create("myglobalname",PT_double,&myglobalvar,PT_ACCESS,PA_REFERENCE,NULL)`
    

This will create an entry named _myglobalname_ that is treated as a _double_ , and will point to _myglobalvar_. **PA_REFERENCE** declares that the value should only be read through the global implementation. The last argument must always be _NULL_ , or the function will behave aberrantly – so don’t skip it. 

### STATUS gl_global_setvar(char *name, …)

This function uses a character string to set the value of a global variable, then returns 0 if the value could not be set as specified, 1 if it could. The arguments either end up as one string in the form (“ _name_ =_val_ ”), or (“ _name_ ”, “ _value_ ”). In both cases, the value is written as a string. 

Example: 

`gl_global_setvar(“myglobal”, “4.360”);`
    

This will set “myglobal” to 4.360. 

Example: 


`gl_global_setvar(“myglobal=camera”);`
    

This will fail, since the string input “camera” is nonsensical for a double value. 

### char *gl_global_getvar(char *name, char*value, int len)

This function will look for the most recently constructed variable published with name, and attempt to convert the contents into value (len chars long) with the value for the global variable. If value is null, a static buffer will be used. In either case, a pointer to the buffer holding the string representation of the global variable’s value will be returned on success, and NULL will be returned if the global variable could not be found, or if insufficient buffer space was available for the conversion. 

### GLOBALVAR *gl_global_find(char *name)

Looks for the global variable published as name and returns the first global variable with that name that was found, if any were. 

### Using Module Variables

Module-level variables use the global variable interface for construction and access. The significant difference is that the variables must be prefixed with the module name and two colons to associate them with a module within the code. Within model files, these variables can be set within the module property block. For example, 

` my_mod/init.cpp: `

`gl_global_create("my_mod::value1", PT_double, &value1, NULL);`

` my_mod_test.glm: `

```
     module my_mod{
        value1 42.0;
     }
```

These module variables will be grouped underneath their modules within model dump XML files. 


### Global Variable Access

Global Variable Access Rights  Variable name | Visible | Saved | Loaded | Access   
---|---|---|---|---  
version.major | √ | √ |  | REFERENCE   
version.minor | √ | √ |  | REFERENCE   
command_line | √ | √ |  | REFERENCE   
environment | √ | √ | √ | PUBLIC   
quiet | √ | √ | √ | PUBLIC   
warn | √ | √ | √ | PUBLIC   
debugger | √ | √ | √ | PUBLIC   
gdb | √ | √ | √ | PUBLIC   
debug | √ | √ | √ | PUBLIC   
test | √ | √ | √ | PUBLIC   
verbose | √ | √ | √ | PUBLIC   
iteration_limit | √ | √ | √ | PUBLIC   
workdir | √ | √ |  | REFERENCE   
dumpfile | √ | √ | √ | PUBLIC   
savefile | √ | √ | √ | PUBLIC   
dumpall | √ | √ | √ | PUBLIC   
runchecks | √ | √ | √ | PUBLIC   
threadcount | √ | √ | √ | PUBLIC   
profiler | √ | √ | √ | PUBLIC   
pauseatexit | √ | √ | √ | PUBLIC   
testoutputfile | √ | √ | √ | PUBLIC   
xml_encoding | √ | √ | √ | PUBLIC   
clock | √ | √ | √ | PUBLIC   
starttime | √ | √ | √ | PUBLIC   
stoptime | √ | √ | √ | PUBLIC   
double_format | √ | √ | √ | PUBLIC   
complex_format | √ | √ | √ | PUBLIC   
object_format | √ | √ | √ | PUBLIC   
object_scan | √ | √ | √ | PUBLIC   
object_tree_balance | √ | √ | √ | PUBLIC   
kmlfile | √ | √ | √ | PUBLIC   
modelname | √ | √ |  | REFERENCE   
execdir | √ | √ |  | REFERENCE   
strictnames | √ | √ | √ | PUBLIC   
website | √ | √ | √ | PUBLIC   
urlbase | √ | √ | √ | PUBLIC   
randomseed | √ | √ | √ | PUBLIC   
include | √ | √ |  | REFERENCE   
trace | √ | √ | √ | PUBLIC   
gdb_window | √ | √ | √ | PUBLIC   
tmp | √ | √ | √ | PUBLIC   
force_compile | √ | √ | √ | PUBLIC   
nolocks | √ | √ | √ | PUBLIC   
skipsafe | √ | √ | √ | PUBLIC   
dateformat | √ | √ | √ | PUBLIC   
minimum_timestep | √ | √ | √ | PUBLIC   
platform | √ | √ |  | REFERENCE   
suppress_repeat_messages | √ | √ | √ | PUBLIC   
maximum_synctime | √ | √ | √ | PUBLIC   
run_realtime | √ | √ | √ | PUBLIC   
no_deprecate | √ | √ | √ | PUBLIC   
sync_dumpfile | √ | √ | √ | PUBLIC   
streaming_io | √ |  |  | PROTECTED   

### Synopsis

C
    
    
     gl_global_create("_#Module name|module-name_ ::_variable-name_ ", 
      PT__[built-in_type],_variable-address _,_
      PT_SIZE,_array-size_ ,
      PT_UNITS,_[units]_ ,
      PT_ACCESS,_access-control-flags_ ,
      PT_DESCRIPTION,_brief-description_ ,
      NULL);
    

C++
    
    
     class [gld_global] {
       [gld_global](const char *name, [PROPERTYTYPE] t, void *p);
     }
    

### Description

The naming convention for module globals requires that the module name precede the global variable name separated by a double colon, as in `_module--name_ ::_variable-name_`. This allows the core to associate the global with the module. If the variable name does not include the module name, it will be treated as a core global. There is nothing to prevent module programmers for doing this, and in some cases this may be useful. 

### Parameters

The follow parameter may be used to define a module or class global variable. 

#### Access control flags

    This identifies how the global may be accessed by other modules and object. See [PT_ACCESS] for details. If omitted, the variable is assumed to be [public].

#### Array size

    Identifies the array size, which is optional. If omitted it is assumed to be 1.

#### Brief description

    This identifies a string constant that provide a brief synopsis of the variable. This description is displayed by --[modhelp] and [XML] output.

#### [Built-in type]

    This identifies what [built-in type] the variable is. This option is required.

#### Module name

    This identifies the module name. The module name is optional, and when omitted causes the variable to become a core global.

#### [Units]

    This identifies the [units] for double and complex variables. The units are optional and if omitted, the variable is considered unitless.

#### Variable name

    This identifies the variable name and is required.

### Examples

### Module globals

Module globals are created whenever a module is loaded. These must be placed in the module [init] function to ensure that they are always created when modules are loaded. 

Note
    Most module implementation is a callback function table to define **gl_create_global**. Therefore calls to this function cannot be completed until the callback table is built using the **set_callback** function. See [source documentation] on **set_callback** for details.

Example (main.cpp)
    
    
    
     #include "gridlabd.h"
     #include "my_class.h"
     char256 my_data = "initial value";
     EXPORT CLASS *init(CALLBACKS *fntable, MODULE *module, int argc, char *[])
     {
       if (set_callback(fntable)==NULL)
       {
         errno = EINVAL;
         return NULL;
       }
       **if ( gl_global_create("my_module::my_data",PT_char256,my_data,**
       **PT_ACCESS,PA_PUBLIC,**
       **PT_DESCRIPTION,"my data example",NULL)==NULL )**
       **throw "unable to create module global char256 my_module::my_data";**
       new my_class(module);
       return my_class::oclass;
     }
    

#### Class globals

Class global are created whenever a class is referenced. These must be placed in the class constructor, which is called only when the class is first referenced. 

Note
    It is unusual to have class globals because they are only created when the class is referenced, but there are cases where this may be preferred to a module global. An example would be a situation in which all object of a given class must share a variable that may be altered by the user but would not be available to the user if the class when the class is not used.

Example (my_class.cpp)
    
    
    
     class my_class {
     public:  my_class(MODULE *);
     private: char256 my_variable;
     };
     static char256 my_class::my_variable = "initial value";
     my_class::my_class(MODULE *module)
     {
       if ( oclass==NULL )
       {
         oclass = gld_class::create(module,"my_class",sizeof(my_class),PC_AUTOLOCK);
         if ( oclass==NULL ) throw "unable to register my_class";
         else oclass->trl = TRL_UNKNOWN;
         defaults = this;
         if ( gl_publish_variables( oclass, 
               NULL ) < 1 ) throw "unable to publish my_class properties";
       }
       else throw "invalid attempt to define class more than once";
       **gld_global my_global("my_module::my_variable",PT_char256,my_variable);**
       **if ( !my_global.isvalid() )**
       **throw "unable to create class global char256 my_module::my_variable";**
       memset(this,0,sizeof(my_class));
       }
     }