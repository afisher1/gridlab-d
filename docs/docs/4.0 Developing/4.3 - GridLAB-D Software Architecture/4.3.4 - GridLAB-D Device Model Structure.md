# GridLAB-D Device Model Structure

## Parameter Declarations

## Class Methods

### Synopsis
    
    
    class _class-name_ {
      [public] _[GLM-type]_ _property-name_[_[Units]_];
      protected _[GLM-type]_ _reference-name_[_[Units]_];
      private _C-type_ _private-name_ ;
      intrinsic create (object _parent_) {
        // ...
        return SUCCESS; // or FAILED
      };
      intrinsic init (object _parent_) {
        // ...
        return SUCCESS; // or FAILED
      };
      intrinsic isa (char* _class-name_) {
        // [Template:NEW30] ...
        return true; // or false
      };
      intrinsic precommit (void) {
        // [Template:NEW30] ...
      };
      intrinsic presync ([TIMESTAMP] _from_ , [TIMESTAMP] _to_) {
        // ...
      };
      intrinsic sync ([TIMESTAMP] _from_ , [TIMESTAMP] _to_) {
        // ...
      };
      intrinsic postsync ([TIMESTAMP] _from_ , [TIMESTAMP] _to_) {
        // ...
      };
      intrinsic plc ([TIMESTAMP] _from_ , [TIMESTAMP] _to_) {
        // ...
      };
      intrinsic commit ([TIMESTAMP] _from_ , [TIMESTAMP] _to_) {
        // [Template:NEW30] ...
      };
      intrinsic notify (char* _property-name_ , int _event_ , void* _value_) {
        // [Template:NEW30] ...
      };
      function _function-name_ (_call arguments..._) {
        // code
      };   
    }
    

### Description

In GridLAB-D, a class is a named structure associated with a particular module or a [runtime] [GLM] file that is registered with the GridLAB-D core. A class can be defined or extended within an [input file], publish [properties], and export callback functions. At minimum, a class must define how it is constructed, and what it does during each synchronization time step. 

The [class directive] can be used to alter the structure of an existing class. 

#### commit

Prior to [Hassayampa (Version 3.0)]

`intrinsic commit (void) {...}`
    The [commit] function is run after all [synchronization] passes have been completed. The commit function must return [SUCCESS] or [FAILED] to indicate the result. The simulation will stop if the return values is not [SUCCESS].

As of [Hassayampa (Version 3.0)]

`intrinsic commit ([TIMESTAMP] _from_ , [TIMESTAMP] _to_) {...}`
    The [commit] function is run after all [synchronization] passes have been completed. The commit function must return a [TIMESTAMP] later than _to_ (or TS_NEVER) to indicate the success. The simulation will stop if the return values is not later than _to_.

#### create

`intrinsic create (object _parent_) {...}`
    The [create] function is run before user-defined values are loaded and [init] is performed. This event allows you to set up each object prior to user values being set by the GLM file. This is the time to set default values and values used to detect whether the user has defined required values (e.g., negative or zero values that are not valid). The [create] function must return [SUCCESS] or [FAILED] to indicate the result. The simulation will stop if the return values is not [SUCCESS].

#### init

**TODO**: 

#### isa

**TODO**: 

#### notify

**TODO**: 

#### plc

**TODO**: 

#### postsync

**TODO**: 

#### precommit

**TODO**: 

#### presync

**TODO**: 

#### sync

**TODO**: 

### Caveat

You should not define classes that are already defined in modules. There's nothing to prevent users from doing this, but the behavior of GridLAB-D under such conditions is not defined. 

Windows users must have [MinGW] installed on their system for the class directive to load properly for anything other than adding public properties. 

### Examples

Verifying class structures

To verify the structure of an existing class use the syntax: 
    
    
    module climate;
    class climate {
      double [temperature][[degF]$]$;
    }
    

If the variable [temperature] is defined but is not a double with [units] [degF], then the load of the GLM file will fail. This allows modelers to be certain that the variable and units remain as expected when a module is loaded. 

Altering class structures

To alter the structure of an existing class by adding new variables, use the syntax: 
    
    
    module climate;
    class climate {
      double elevation[[ft]];
    }
    

If the variable `elevation` is not defined, then it will be added with the [units] specified. 

Creating new classes

To create a new [runtime class] with a double called `elevation` measured in [[ft]] use the syntax: 
    
    
    class my_class {
       double elevation[[ft]];
    }
    

**TODO**:  Add an example of a full-fledged class with runtime components. 

## Linking to Parameters Between Objects

### Synopsis
    
    
    gl_publish_variable(CLASS *_oclass, PROPERTYTYPE_ type _, const char *'name_ , size_t _offset_ , ..., NULL);
    

Declarations
    
    
    #include "gridlabd.h"
    GL_ATOMIC(_type_ ,_name_);
    GL_STRUCT(_type_ ,_name_);
    GL_STRING(_type_ ,_name_);
    GL_ARRAY(_type_ ,_name_ , _size_);
    GL_BITFLAGS(_type_ ,_name_);
    

General accessors
    
    
    size_t get__name_ _offset();
    gld_property get__name_ _property();
    

Atomic accessors
    
    
    _type_ get__name_();
    _type_ get__name_(gld_rlock& _rlock_);
    _type_ get__name_(gld_wlock& _wlock_);
    void set__name_(_type_ _value_);
    void set__name_(_type_ _value_ , gld_wlock& _wlock_);
    

Struct accessors
    
    
    _type_ get__name_();
    _type_ get__name_(gld_rlock& _rlock_);
    _type_ get__name_(gld_wlock& _wlock_);
    void set__name_(_type_ _value_);
    void set__name_(_type_ _value_ , gld_wlock& _wlock_);
    

String accessors
    
    
    char* get__name_();
    char* get__name_(gld_rlock& _rlock_);
    char* get__name_(gld_wlock& _wlock_);
    void set__name_(char* _value_);
    void set__name_(char* _value_ , gld_wlock& _wlock_);
    char get__name_(size_t _n_);
    char get__name_(size_t _n_ , gld_rlock& _rlock_);
    void set__name_(char _value_ , size_t _n_);
    void set__name_(char _value_ , size_t _n_ , gld_wlock& _wlock_);
    

Array accessors
    
    
    _type_ * get__name_();
    _type_ * get__name_(gld_rlock& _rlock_);
    _type_ * get__name_(gld_wlock& _wlock_);
    void set__name_(_type_ * _value_);
    void set__name_(_type_ * _value_ , gld_wlock& _wlock_);
    _type_ get__name_(size_t _n_);
    _type_ get__name_(size_t _n_ , gld_rlock& _rlock_);
    void set__name_(_type_ _value_ , size_t _n_);
    void set__name_(_type_ _value_ , size_t _n_ , gld_wlock& _wlock_);
    

Bitflag accessors
    
    
    _type_ get__name_(_type_ mask=-1);
    _type_ get__name_(gld_rlock& _rlock_);
    _type_ get__name_(gld_wlock& _wlock_);
    void set__name_(_type_ _value_);
    void set__name_ _bits(_type_ _value_);
    void clr__name_(_type_ _value_);
    void set__name_(_type_ _value_ , gld_wlock& _wlock_);
    

### Description

The gl_publish_variable function is a variable argument list call used to publish the publicly accessible properties of a GridLAB-D class. The argument list must contain a least one property type, property name and property offset tuple. The property type must be one of the members of [PROPERTYTYPE]. The property name must be a `const char *` and the property offset must be `size_t`. The property list must be NULL terminated. 

Additional options may be added after each property definition tuple. These options include 

PT_INHERIT
    This will include the properties of the parent class (if any) in searches of this class's properties.

PT_ACCESS, _access_
    This allows you to set special access rights (see [PROPERTYACCESS] for details).

PT_FLAGS, _flags_
    This allows you to set special property flags (see [PROPERTYFLAGS] for details).

PT_UNIT, "_definition_ "
    This allows you to set the units for double and complex properties.

PT_SIZE, _size_
    This allows you to define an array of properties.

PT_EXTEND
    This allows you to enlarge the class by the size of the property.

PT_EXTENDBY, _bytes_
    This allows you to enlarge the class by the number of _bytes_ given.

PT_DESCRIPTION, "_description_ "
    This allows you to provide a text description of the property for use in given users help (see --[modhelp] for details)

PT_KEYWORD, "_name_ ", _value_
    This allows you to define one or more keyword values to associate with the property (see set and enumeration for details). Note that you must cast constants to appropriate [built-in types] to avoid argument alignment problems.

### Declarations

#### GL_ATOMIC

GL_ATOMIC types are used strictly for data types that can set as an atomic operation on all platforms. 

#### GL_STRUCT

If the data type cannot be set as an atomic operation, you must use the GL_STRUCT declaration. 

#### GL_STRING

Any data type that is a character array can be declared as GL_STRING to enable string accessors. 

#### GL_ARRAY

Data types that are general arrays can be declared as GL_ARRAY to enable array accessors. 

#### GL_BITFLAGS

Bitmap and bitflags integers can be declared as GL_BITFLAGS to enable bit set and clear accessors. 

### Example

The following example is taken from the `[assert](https://github.com/gridlab-d/gridlab-d/trunk/assert)` module: 

Header file (`[assert.h](https://github.com/gridlab-d/gridlab-d/trunk/assert/assert.h)`)
    
    
    class g_assertÂ : public gld_object {
    public:
      typedef enum {AS_INIT=0, AS_TRUE=1, AS_FALSE=2, AS_NONE=3} ASSERTSTATUS;
      GL_ATOMIC(ASSERTSTATUS,status)
      GL_STRING(char1024,target);
      GL_STRING(char32,part); 
      GL_ATOMIC(PROPERTYCOMPAREOP,relation);
      GL_STRING(char1024,value);
      GL_STRING(char1024,value2);
      // ...
    };
    

Implementation file (`[assert.cpp](https://github.com/gridlab-d/gridlab-d/trunk/assert/assert.cpp)`)
    
    
    g_assert::g_assert(MODULE *module)
    {
      // ...
      if (gl_publish_variable(oclass,
        PT_enumeration,"status",get_status_offset(),PT_DESCRIPTION,"desired outcome of assert test",
          PT_KEYWORD,"TRUE",(enumeration)AS_TRUE,
          PT_KEYWORD,"FALSE",(enumeration)AS_FALSE,
          PT_KEYWORD,"NONE",(enumeration)AS_NONE,
        PT_char1024, "target", get_target_offset(),PT_DESCRIPTION,"the target property to test",
        PT_char32, "part", get_part_offset(),PT_DESCRIPTION,"the target property part to test",
        PT_enumeration,"relation",get_relation_offset(),PT_DESCRIPTION,"the relation to use for the test",
          PT_KEYWORD,"==",(enumeration)TCOP_EQ,
          PT_KEYWORD,"<",(enumeration)TCOP_LT,
          PT_KEYWORD,"<=",(enumeration)TCOP_LE,
          PT_KEYWORD,">",(enumeration)TCOP_GT,
          PT_KEYWORD,">=",(enumeration)TCOP_GE,
          PT_KEYWORD,"!=",(enumeration)TCOP_NE,
          PT_KEYWORD,"inside",(enumeration)TCOP_IN,
          PT_KEYWORD,"outside",(enumeration)TCOP_NI,
        PT_char1024, "value", get_value_offset(),PT_DESCRIPTION,"the value to compare with for binary tests",
        PT_char1024, "within", get_value2_offset(),PT_DESCRIPTION,"the bounds within which the value must bed compared",
        PT_char1024, "lower", get_value_offset(),PT_DESCRIPTION,"the lower bound to compare with for interval tests",
        PT_char1024, "upper", get_value2_offset(),PT_DESCRIPTION,"the upper bound to compare with for interval tests",
      NULL)<1)
         throw "assert property publish failed";
      // ...
    }




## Exposing Methods to Other Objects

### Synopsis
    
    
    FUNCTIONADDR (*_call_)(object *_object_);
    gl_publish_function(class *_oclass_ , const char *_name_ , [FUNCTIONADDR] _call_);
    FUNCTIONADDR gl_get_function(object *_obj_ , const char *_name_);
    

### Remarks

Classes may expose methods to other classes using the **gl_publish_function** API call. The function address can then be looked up and called as needed. The argument list is not specified and thus cannot be verified when the method is called. 

### Example

Target class
    
    
    #include <stdarg.h>
    #include "gridlabd.h"
    EXPORT void* _my_function_(OBJECT *_obj_ , ...)
    {
      va_list ptr;
      va_start(ptr,obj);
      // **TODO** implement your function here
      va_end(ptr);
      return NULL; // **TODO** return data pointer
    }
    

Calling class
    
    
    #include "gridlabd.h"
    gld_object *target = get_object("_target_object_name_ ");
    FUNCTIONADDR _my_function_ = target->get_function("_my_function_ ");
    void *result = my_function(target->my()); // **TODO** add arguments to call
    

